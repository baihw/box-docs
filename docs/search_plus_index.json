{"./":{"url":"./","title":"简介","keywords":"","body":"简介 一个希望能够保持简约，并且具有较强的环境适应性的快速开发框架。 文档在线阅读 访问文档源码 访问示例项目 目标 简化开发模型，降低心智负担 抽象依赖，标准化，敏捷和可替换性 不因技术潮流的变更影响到业务代码的复用性 对海量生态组件的价值筛选、兼容和集成保证以及支撑服务 "},"src/quickStart.html":{"url":"src/quickStart.html","title":"快速开始","keywords":"","body":"快速开始 本文档编写时使用的测试环境如下 Jdk8u181 Maven3.5.4 Idea 2019.2.1 开源版 Mysql 5.7 64位windows10 本地搭建多模块示例项目开发环境 从Github下载box-examples示例项目。下载地址 解压到本地非中文目录，如：D:/temp/box-examples，解压后的目录如下： 启动Idea，点击“Open”，选择示例项目根目录下的“pom.xml”文件，点击“Open as Project”导入工程。 进入工程后的结构如下： 根据需要使用“scripts/mysql_init.sqll”文件中的脚本，导入数据库初始化数据。 根据本地环境，修改“application-dev.properties”配置文件中的数据库连接信息。 打开“App.java”，右键，运行。 访问 http://127.0.0.1:9000 查看效果吧。 本地搭建无模块示例项目开发环境 待补充。 "},"src/specification.html":{"url":"src/specification.html","title":"规范约定","keywords":"","body":"规范约定 使用统一的规范，便于统一大家的思想认知，降低出错的概率；不要等出现问题了才想到解决，而是准备好了，才不会出现问题。 有规范一定会产生制约，虽然规范制定时希望能够最大程度的兼容大家的开发习惯，以降低大家的不适应程度，但是众口难调，难免有一些地方会跟一部分人的习惯产生冲突。但是没有绝对的对错，适当的规范和标准绝不是消灭代码内容的创造性，而是限制过度个性化，以一种普遍认可的统一方式降低协同成本，提升协作沟通效率。 如何落实 前期除了一些固化在框架里的规范之外，其它的规范主要还是靠大家自觉执行，以及通过适当的代码走查来保证。后期可以考虑提供一些工具来保障规范的执行，比如集成在代码质量管理流程中自动执行检查等。 box-api（固化在框架里的一种代码层面的规范） box-api项目里边基本都是接口，和少量的一些方便开发过程中使用的快捷操作类。 box-impl项目是当前基于spring框架封装的默认实现版本。 box-springboot项目是增加了springboot环境依赖的版本。 如果你有兴趣也可以提供自己的实现版本，前提是必须提供box-api的绝对兼容性，即基于box-api开发的项目应该在不做任何修改的情况下能稳定运行于你的发行版。 所以接下来当我们需要特定功能时，应该尝试着去基于api来思考问题，而不是基于具体的实现，接口中定义的行为基本上就决定了功能的使用方式与使用规范。 比如在需要缓存功能时我们考虑的应该是我们实际想要达到的效果是什么，基于我们的需求来抽象接口行为，而不是具体的redis或者ehcache组件提供了什么样的API使用方式来决定我们在使用上的规范。 box-api中的任何组件都可以被替换，如果api中的某个组件无论是性能还是结果等任意一个方面达不到期望的目标值，都可以很轻松的自行替换，而不用必须等待框架的版本发布。 举个例子吧，如果项目开发过程中发现了StringUtils工具的行为在特定环境下与预期结果不一致，而且时间又很紧迫，走框架更新流程来不及，此时可以在框架配置文件中配置StringUtils工具切换到项目组自己的实现，自行掌控问题处理进度。有空闲时间后再提交相关问题到框架组，待框架更新发布后，在下次升级时移除自定义配置项即可，以此达到框架组与产品组之间的一种高效协作方案。 一些约定 框架注解类 为了方便大家记忆，框架中提供的注解基本上都有box前缀，如BoxDao，BoxAction，... 项目包 建议每个项目规范好自己的项目包名，将项目启动类放置于项目包名下，遵守此约定，可免于配置dao包目录，action包目录等信息。例如项目包名为“com.test.project1”，则约定部分如下： com.test.project1.App.java - 项目启动类 com.test.project1.action - action包 com.test.project1.entity - entity包 com.test.project1.dao - dao包 分模块 分模块的项目，模块应该归在项目包下，例如项目包名为“com.test.project1”，模块1为module1，模块2为module2，则约定部分如下： com.test.project1.module1 - 模块1包名 com.test.project1.module2 - 模块2包名 模块工程划分为：api（模块接口），impl（模块实现），route（项目路由），web（web环境启动项目），如下： module1-api module1-impl module2-api module2-impl project1-route project1-web "},"src/guide/config.html":{"url":"src/guide/config.html","title":"框架配置","keywords":"","body":"框架配置 框架配置性的文本统一放置在web项目的src/main/resources目录下，主要目录文件如下： application.properties - springboot主配置文件 application-dev.properties - springboot开发环境相关信息配置文件 application-prod.properties - springboot正式环境相关信息配置文件 config - 不依赖springboot环境的相关配置文件存放目录 box_config.properties - 框架配置文件 redis.properties - redis配置文件（可选） shiro.ini - shiro配置文件（可选） mybatis - mybatis相关文件存放目录（可选） mybatis-config.xml - mybatis配置文件 mapper - mapper xml 文件存放目录 static - 静态文件存放目录（可选） 配置对象 配置对象提供了框架中一些可配置组件的定制化功能，这些组件使用Java对象进行配置而不是配置文件，因为这通常是为了配合统一的开发规范，比如前后端约定的数据交互标准等，有定制的需求，但不会在程序开发发布完成后由运维人员调整，没有运行期进行配置更改的必要。 配置对象是一个实现了com.wee0.box.IBoxConfigObject接口的类，如下： public class SimpleBoxConfigObject implements IBoxConfigObject { @Override public int getBizExceptionHttpStatusCode() { return 500; } @Override public int getPermissionExceptionHttpStatusCode() { return 403; } @Override public IBizCode getSystemErrorBizCode() { return BizCodeDef.S000000; } @Override public IBizCode getSystemErrorInfoBizCode() { return BizCodeDef.S000001; } @Override public IBizCode getNeedLoginBizCode() { return BizCodeDef.NeedLogin; } @Override public IBizCode getUnauthorizedBizCode() { return BizCodeDef.Unauthorized; } @Override public Object getWrappedActionReturnValue(Object returnValue) { return CmdFactory.create(\"200\", \"ok\", returnValue); } } 在box_config.properties文件中指定，如下： configObject=com.wee0.box.impl.SimpleBoxConfigObject "},"src/guide/dao.html":{"url":"src/guide/dao.html","title":"数据访问层","keywords":"","body":"数据访问层 数据访问层当前版本仅提供了基于mybatis的实现，框架提供了基本的单表增、删、改、查功能的自动适配，只需要继承IBaseDao即可使用，不需要写mapper.xml文件。如果某个自动适配的结果与预期不一致时，可以选择显式的在mapper.xml文件中进行定义覆盖。当mapper.xml中存在对应方法的语句定义时，mapper.xml文件中显式声明的优先级更高。关于mybatis的Mapper xml编写方法，这里就不再赘述了，参考 官方文档 或者 官方中文翻译文档。 实体类 @BoxTable(name = \"SYS_USER\") public class SysUserEntity extends BaseEntity { /** * 用户名 */ @BoxColumn(name = \"USER_NAME\") protected String userName; /** * 密码 */ protected String password; /** * 用户昵称 */ @BoxColumn(name = \"NICK_NAME\") protected String nickName; /** * 性别 */ protected int sex; /** * 邮箱 */ protected String email; /** * 手机 */ protected String mobile; // 此处省略了 geeter / setter 方法 } BaseEntity - 一个基础实体对象，封装了基本上每个表都会具备的一些通用属性。 BoxTable - 表标记注解，当实际的表名与实体类类名不一致时，可通过name属性指定映射关系。 BoxColumn - 列标记注解，当实际的列名与实体类属性名不一致时，可通过name属性指定映射关系。 BaseEntity主要代码如下 @BoxIgnore public class BaseEntity extends AbstractEntity { @BoxId @BoxColumn(name = \"ID\") protected String id; /** * 创建时间 */ @BoxColumn(name = \"CREATE_TIME\") protected Date createTime; /** * 创建用户 */ @BoxColumn(name = \"CREATE_USER\") protected String createUser; /** * 修改时间 */ @BoxColumn(name = \"UPDATE_TIME\") protected Date updateTime; /** * 修改用户 */ @BoxColumn(name = \"UPDATE_USER\") protected String updateUser; /** * 是否标记删除:0-未标记删除；1-标记删除； */ @BoxColumn(name = \"IS_DELETED\") protected Boolean isDeleted; // 此处省略了 geeter / setter 方法 } 实体类代码生成工具 实体类也可以通过框架提供的内置工具进行生成，当前版本使用的是FreeMarker模板引擎进行生成，所以需要确认在使用生成工具类时正确引入了FreeMarker依赖，依赖如下： org.freemarker freemarker 调用生成代码如下： Map _dataModel = new HashMap<>(); // 实体类所属包名 _dataModel.put(\"entityPackage\", \"com.wee0.box.examples.multiModule.module1.entity\"); // 实体类继承的公共基类 _dataModel.put(\"entityBase\", \"com.wee0.box.examples.multiModule.module1.entity.BaseEntity\"); // 作者名称 _dataModel.put(\"author\", \"baihw\"); // 文件创建时间 _dataModel.put(\"createDate\", DateUtils.getCurrentDate()); // 生成的实体类保存文件夹位置 File _entityDir = new File(\"D:/test\"); // 不需要在实体类中包含的列，通常是因为在公共基类中已经统一定义了。 Set _excludeColumns = new HashSet<>(6); _excludeColumns.add(\"ID\"); _excludeColumns.add(\"CREATE_TIME\"); _excludeColumns.add(\"CREATE_USER\"); _excludeColumns.add(\"UPDATE_TIME\"); _excludeColumns.add(\"UPDATE_USER\"); _excludeColumns.add(\"IS_DELETED\"); // 不需要在实体类中包含的表，这里排除关系表的生成。 Set _excludeTables = new HashSet<>(2); _excludeTables.add(\"sys_user_role_rel\"); _excludeTables.add(\"sys_role_permission_rel\"); // 自定义命名策略 ISqlTemplateHelper.INamePolicy _namePolicy = new ISqlTemplateHelper.INamePolicy() { @Override public String renameEntity(String original, String current) { // 统一加上Entity后缀。 return current + \"Entity\"; } }; // 调用数据库模板助手类实例生成实体类的方法 SqlTemplateHelper.impl().generateEntities(_dataModel, \"entity.ftl\", _entityDir, _excludeColumns, _excludeTables, _namePolicy); entity.ftl 模板文件可以从示例项目web工程的 src/test/resources/templates/entity.ftl 位置获取，也可以通过调整模板文件来定制自己的最终生成格式，示例项目web工程的 TestGenerate.java 源码中有此部分的测试代码。 Dao接口 @BoxDao public interface SysUserDao extends IBaseDao { int updatePassword(SysUserEntity sysUserEntity); } BoxDao - Dao对象注解，标注了此注解的接口在启动时进行扫描处理。 IBaseDao - 一个包含了简单增、删、改、查操作的基础接口，继承自此接口中的方法，不需要自己编写Mapper xml实现，由框架根据数据库环境自动适配，当前版本支持的数据库有Mysql、Oracle。 String - 主键数据类型 此例子中，只需要在Mapper xml中提供自已定义的updatePassword方法的sql语句即可。 IBaseDao接口定义代码如下 /** * 插入数据 * * @param entity 实体对象 * @return 受影响的记录数 */ int insertEntity(S entity); /** * 修改数据 * * @param entity 实体对象 * @return 受影响的记录数 */ int updateEntity(S entity); /** * 删除指定标识数据 * * @param id 唯一标识 * @return 受影响的记录数 */ int deleteById(ID id); /** * 删除指定标识数据 * * @param ids 唯一标识集合 * @return 受影响的记录数 */ int deleteByIds(List ids); /** * 删除所有数据 * * @return 受影响的记录数 */ int deleteAll(); /** * 统计总数量 * * @return 总数量 */ long countAll(); /** * 是否存在指定标识数据 * * @param id 唯一标识 * @return true / false */ Boolean existsById(ID id); /** * 查询指定标识数据 * * @param id 唯一标识 * @return 数据 */ T queryById(ID id); /** * 查询指定标识数据 * * @param ids 唯一标识集合 * @return 数据 */ List queryByIds(List ids); /** * 查询所有数据 * * @return 所有数据 */ List queryAll(); /** * 查询分页数据 * * @param pageNum 页码 * @param pageSize 每页大小 * @return 分页数据 */ List queryAllByPage(int pageNum, int pageSize); 分页支持 使用方法 默认对名称以“Page”结尾的查询方法进行拦截统一处理，可以通过配置修改为自定义的规则，如下： Java代码使用示例： Map _params = PageHelper.impl().createPageParams(2, 10); // 增加其它参数 _params.put(\"isDeleted\", false); // 结果集返回的是当前页的数据 List _data = sysUserDao.queryAllByPage(_params); // 需要分页相关详细数据，如页数，总行数等可以从IPage对象获取。 IPage _page = PageHelper.impl().parseMap(_params); System.out.println(\"_page: \" + _page); 事务支持 使用方法 boolean _result = TxManger.impl().tx(() -> { // 修改其它属性，不修改唯一标识 _sysUserDao.updateEntity(_user); // 唯一标识重复，插入失败 _sysUserDao.insertEntity(_user); }); // 如果dao方法执行发生异常，将会回滚事务，打印日志，然后返回false。 System.out.println(\"transaction result: \" + _result); mybatis单文件多数据库语法支持 适用场景 一些被其它项目依赖的项目，如果对不同环境进行区别打包发布的话，一来比较麻烦，二来也会导致其它项目在引用时需要根据不同的环境去切换依赖，如oracle环境依赖 proj-x.y.z-oracle 版本，mysql环境依赖 proj-x.y.z-mysql 版本。由于项目中大部分使用的都是标准sql语法，需要针对数据库环境进行定制的语法点并不多，所以我们可以选择此方案。反之，如果差异性太大，没有多少可重用语法的情况下，建议使用不同数据库不同目录的处理方式，但这并不是个单选问题，它们是可以并存的，所以不用担心必须做出唯一选择，请在合适的场景选择合适的方案。 使用方法 在需要对特定数据库进行特殊处理的语句节点加入数据库标识属性databaseId，当前可选的值有：mysql, postgres, oracle, db2, sybase, microsoft, h2。 参考以下mapper.xml文件示例 ID, TITLE = to_date(#{startDt},'yyyy-mm-dd') ]]> = #{startDt} ]]> SELECT FROM SYS_USER ORDER BY CREATE_DATE DESC select 1 from dual select 2 select 1 mybatis分目录多数据库支持 待补充。。。 "},"src/guide/controller.html":{"url":"src/guide/controller.html","title":"路由控制层","keywords":"","body":"控制层 控制层主要使用的注解为BoxAction，由类上注解与方法注解组合为最终的请求路由。类上注解标记不能省略，但路径可以不指定，方法注解可以省略。默认情况下，标记了BoxAction的类中，所有public方法都会自动映射。当不指定路由路径时，以类名首字母小写后的路径为类路径部分，以方法名为方法路径部分，配合基准路径进行组合。默认的基准路径为：\"/api\"+不包含action包根路径的包名。 举个例子 package com.wee0.box.examples.multiModule.action.test; @BoxAction public class User { public boolean login(String loginId, String loginPwd) { ISubject _subject = SubjectContext.getSubject(); IPasswordToken _passwordToken = SubjectContext.getTokenFactory().createPasswordToken(loginId, loginPwd); _subject.login(_passwordToken); return true; } public boolean logout() { ISubject _subject = SubjectContext.getSubject(); _subject.logout(); return true; } private void internal() {} } com.wee0.box.examples.multiModule.action 为action包根路径。 login方法的请求路径为：/api/test/user/login。 logout方法的请求路径为：/api/test/user/logout1。 internal方法因为是非public方法，所以不会自动映射。 做些修改，如下： package com.wee0.box.examples.multiModule.action.test; @BoxAction(\"/user\") public class User { public boolean login(String loginId, String loginPwd) { ISubject _subject = SubjectContext.getSubject(); IPasswordToken _passwordToken = SubjectContext.getTokenFactory().createPasswordToken(loginId, loginPwd); _subject.login(_passwordToken); return true; } @BoxAction(\"/logout1\") public boolean logout() { ISubject _subject = SubjectContext.getSubject(); _subject.logout(); return true; } private void internal() {} } com.wee0.box.examples.multiModule.action 同样为action包根路径。 login方法的请求路径为：/api/user/login。 logout方法的请求路径为：/api/user/logout1。 internal方法因为是非public方法，所以不会自动映射。 统一的响应数据 框架默认响应包含code, message, data三个字段中不为null数据的json格式，如果方法逻辑正常执行得到的返回值将被作为data数据值，code默认为200，message默认为“ok”，可以在配置文件\"application.properties\"修改，如下： # 设置请求处理成功时返回的响应代码。默认：200 box.action.default.resultCode=200 # 设置请求处理成功时返回的响应消息。默认：ok box.action.default.resultMessage=ok 如果方法逻辑未按预期执行，可通过业务异常工厂类抛出表示错误的业务代码与提示消息，如下： throw BizExceptionFactory.create(BizCodeDef.S000001, \"提示消息参数\"); 特殊场景下，如果需要自定义响应数据格式时，仅需要将自定义的响应数据类标记为实现了IStruct接口，然后在业务逻辑方法返回自定义类型即可，如下： public class CustomResult implements IStruct { // ...... } 文件上传 当前版本的文件上传功能基于 commons-fileupload 组件实现，所以使用之前，请先确认正确添加了依赖 commons-fileupload commons-fileupload 在启动类上排除springboot对 commons-fileupload 组件的自动装配 @SpringBootApplication(exclude = MultipartAutoConfiguration.class) public class App { } 业务代码中使用上传组件的示例代码如下： @BoxAction public class UpDown { @BoxInject private IUploadRequestUtils uploadRequestUtils; public String upload(HttpServletRequest request) { IUploadRequest _uploadRequest = uploadRequestUtils.parseRequest(request); IUploadFile _file1 = _uploadRequest.getUploadFile(\"file1\"); String _toFile = \"D:/test/\" + _file1.getName(); _file1.saveTo(new File(_toFile)); return _file; } } "},"src/guide/subject.html":{"url":"src/guide/subject.html","title":"认证鉴权","keywords":"","body":"认证鉴权 当前版本的认证鉴权组件时通过shiro实现的，所以使用此组件需要增加shiro依赖，并增加shiro.ini配置。 org.apache.shiro shiro-core shiro.ini参考配置： [main] boxJdbcRealm = com.wee0.box.subject.shiro.BoxJdbcRealm boxJdbcRealm.queryUser = select id from sys_user where user_name=? and user_pwd= ? boxJdbcRealm.queryRole = select a.role_name from sys_role a join sys_user_role_rel b on a.id=b.role_id where b.user_id=? boxJdbcRealm.queryPermission = select a.permission_code from sys_permission a join sys_role_permission_rel b on a.id=b.permission_id join sys_user_role_rel c on c.role_id=b.role_id where c.user_id=? securityManager.realms = $boxJdbcRealm # 基于缓存的会话数据访问对象 sessionDAO = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO securityManager.sessionManager.sessionDAO = $sessionDAO # 会话标识生成器 sessionIdGenerator = com.wee0.box.subject.shiro.BoxSessionIdGenerator securityManager.sessionManager.sessionDAO.sessionIdGenerator = $sessionIdGenerator # 3,600,000 milliseconds = 1 hour securityManager.sessionManager.globalSessionTimeout = 3600000 cacheManager = com.wee0.box.subject.shiro.BoxCacheManager securityManager.cacheManager = $cacheManager BoxJdbcRealm - 通过关系型数据库管理用户、角色、权限信息的认证实现 boxJdbcRealm.queryUser - 配置进行登陆认证时执行的数据库查询语句，接收2个参数：登陆标识、登陆密码，返回一个用户唯一标识。可按照此规则根据项目数据库设计来修改此语句。 boxJdbcRealm.queryRole - 配置查询登陆用户角色名称集合的语句，接收1个参数：用户登陆成功后上边语句返回的用户唯一标识 ，返回一组角色名称集合。如：admin，guest，...。 boxJdbcRealm.queryPermission - 配置查询登陆用户权限名称集合的语句，接收1个参数：用户登陆成功后上边语句返回的用户唯一标识 ，返回一组权限名称集合。如：common_read，common_write，...。 BoxCacheManager - 基于框架缓存组件适配的shiro会话数据管理数据存储组件。当框架使用redis做为缓存实现时，可实现多节点共享会话数据功能。 Java注解 为了方便在Java代码中使用认证鉴权功能，提供了权限与角色检查支持的注解，可以在BoxAction注解的类中使用。 @BoxAction public class Test { // 请求此方法需要用户具备名称为“common_delete”的权限。 @BoxRequirePermissions(\"common_delete\") public Boolean permission1() {} // 请求此方法需要用户同时具备名称为“common_read”和“common_query”的权限。 @BoxRequirePermissions(value = {\"common_read\", \"common_query\"}) public Boolean permission2() {} // 请求此方法需要用户具备名称为“admin”的角色。 @BoxRequireRoles(\"admin\") public Boolean role1() {} // 请求此方法需要用户具备名称为“admin”或者“guest”的角色。 @BoxRequireRoles(value = {\"admin\", \"guest\"}, logical = BoxRequireLogical.OR) public Boolean role2() {} // 请求此方法需要用户具备名称为“admin”的角色，并且具备名称为“common_delete”的权限。 @BoxRequireRoles(\"admin\") @BoxRequirePermissions(\"common_delete\") public Boolean rolePermission() {} } 其它注解： BoxRequireIgnore - 用在默认不允许访问的策略环境中，用来标识不需要用户登陆即可访问。 BoxRequireUser - 用在默认允许访问的策略环境中，用来标识需要用户登陆后访问。 "},"src/guide/code.html":{"url":"src/guide/code.html","title":"业务编码","keywords":"","body":"业务编码 统一的业务编码处理组件，提供国际化支持（非默认，需配置开启）。 业务编码默认的配置文件名为 biz_code.properties，配置文件中的配置值可覆盖业务编码初始化器中提供的默认值，配置文件示例如下： S0000001=系统异常，请跟管理员联系 S0000002=系统异常，信息：{0} param：{1} param：{2} 自定义自己的业务编码 自定义的业务编码必须是枚举类型，且实现IBizcode接口才能被添加到业务编码管理器中。 类名称建议统一使用BizCode前缀，便于使用者在IDE中进行自动提示，如BizCodeSys，BizCodeUser，...，这样不用刻意查找文档，只要在IDE中输入BizCode就可诱导出各模块的自定义编码。如下： import com.wee0.box.code.IBizCode; public enum BizCodeTest implements IBizCode{ SystemError(\"S0000001\"), SystemErrorInfo(\"S0000002\"); private final String CODE; BizCodeTest(String code) { this.CODE = code; } @Override public String getCode() { return this.CODE; } } 如果有提供默认值，则可以提供一个实现了IBizCodeInitializer接口的对象。如下： import com.wee0.box.code.IBizCodeInitializer; public class BizCodeTestInitializer implements IBizCodeInitializer{ @Override public void initialize(IBizCodeSetter setter) { setter.set(BizCodeTest.SystemError, \"系统异常，请跟管理员联系\"); setter.set(BizCodeTest.SystemErrorInfo, \"系统异常，信息：{0} param：{1} param：{2}\"); } } 也可以合并在同一个枚举类中完成。如下： public enum BizCodeTest implements IBizCode, IBizCodeInitializer{ SystemError(\"S0000001\"), SystemErrorInfo(\"S0000002\"); private final String CODE; BizCodeTest(String code) { this.CODE = code; } @Override public String getCode() { return this.CODE; } @Override public void initialize(IBizCodeSetter setter) { setter.set(SystemError, \"系统异常，请跟管理员联系\"); setter.set(SystemErrorInfo, \"系统异常，信息：{0} param：{1} param：{2}\"); } } 在Java代码中注册自定义业务枚举类和初始化器 import com.wee0.box.code.BizCodeManager; public class App{ public void init(){ BizCodeManager.impl().addBizCodeEnum(BizCodeTest.class); // 如果枚举类同时实现了IBizCodeInitializer接口，则不需要重复注册初始化器。 BizCodeManager.impl().addBizCodeInitializer(new BizCodeTestInitializer()); } } 在框架配置文件box_config.properties中注册自定义业务枚举类和初始化器 # 业务编码枚举类，如果有多个使用逗号（,）隔开。 bizCodeManager.bizCodeEnums=test.BizCodeTest # 业务编码默认值初始化器，如果有多个使用逗号（,）隔开。如果枚举类同时也是初始化器，不用重复配置。 bizCodeManager.bizCodeInitializers=test.BizCodeTestInitializer 使用 为了方便使用，在box-api库中提供了快捷入口类BizCodeManager，使用此类可进行常用方法的操作。如下： import com.wee0.box.code.BizCodeManager; import org.junit.Test; import org.junit.Assert; public class AppTest{ @Test public void testGetCodeInfo() { IBizCodeInfo _bizCodeInfo = BizCodeManager.impl().getCodeInfo(BizCodeTest.SystemErrorInfo, \"p1\", \"p2\", \"p3\"); Assert.assertNotNull(_bizCodeInfo); Assert.assertEquals(\"系统异常，信息：{0} param：{1} param：{2}\", _bizCodeInfo.getText()); Assert.assertEquals(\"系统异常，信息：p1 param：p2 param：p3\", _bizCodeInfo.formatText()); Assert.assertEquals(\"系统异常，信息：p2 param：p1 param：p0\", _bizCodeInfo.formatText(\"p2\", \"p1\", \"p0\")); Assert.assertEquals(\"系统异常，信息：p1 param：{1} param：{2}\", _bizCodeInfo.formatText(\"p1\")); } } 业务编码在处理业务异常中的应用 import com.wee0.box.exception.BizExceptionFactory; public class BizExceptionFactoryTest{ public void ex1(){ throw BizExceptionFactory.create(BizCodeTest.SystemError); } public void ex2(){ throw BizExceptionFactory.create(BizCodeTest.SystemErrorInfo, \"信息参数1\", \"信息参数2\", \"信息参数3\"); } } 国际化支持 在框架配置文件box_config.properties中设置使用支持国际化的业务编码存储对象： # 编码存储对象：不配置默认为simpleStore，如果需要国际化支持，则配置为i18nStore。 bizCodeManager.bizCodeStore=i18nStore 提供对应语言的业务编码配置文件，当前版本支持中文简体、中文繁体、英文。 config/biz_code_zh_CN.properties config/biz_code_zh_TW.properties config/biz_code_en.properties 使用方式与前边介绍的非国际化场景的使用方式一样，只是在需要切换语言的地方增加一个语言切换的调用，默认语言为简体中文。示例代码如下： import com.wee0.box.i18n.Language; import com.wee0.box.i18n.Locale; import com.wee0.box.code.BizCodeManager; import org.junit.Test; import org.junit.Assert; public class AppTest{ @Test public void testGetCodeInfo() { IBizCodeInfo _bizCodeInfo; Locale.impl().setLanguage(Language.en); _bizCodeInfo = BizCodeManager.impl().getCodeInfo(BizCodeTest.SystemError); Assert.assertEquals(\"system exception\", _bizCodeInfo.getText()); Locale.impl().setLanguage(Language.zh_TW); _bizCodeInfo = BizCodeManager.impl().getCodeInfo(BizCodeTest.SystemError); Assert.assertEquals(\"系統异常\", _bizCodeInfo.getText()); Locale.impl().setLanguage(Language.zh_CN); _bizCodeInfo = BizCodeManager.impl().getCodeInfo(BizCodeTest.SystemError); Assert.assertEquals(\"系统异常\", _bizCodeInfo.getText()); } } "},"src/guide/log.html":{"url":"src/guide/log.html","title":"日志","keywords":"","body":"日志 日志组件包：com.wee0.box.log 当前版本采用slf4j消息格式规范，消息文本中使用{}作为参数占位符。 示例：log.trace(\"test p1:{}, p2:{}.\", 1, 2 ); 输出：test p1:1, p2:2. 独立代码中使用方式如下： import com.wee0.box.log.ILogger; import com.wee0.box.log.LoggerFactory; public class LogTest{ private static final ILogger log = LoggerFactory.getLogger(LogTest.class); public static void main(String[] args) { // 最低级别的跟踪日志 log.trace(\"trace..., p1:{}\", 1); // 开发调试过程中建议使用的调试日志 log.debug(\"debug..., p1:{}\", 2); // 需要向用户展示的日志 log.info(\"info..., p1:{}\", 3); // 警告日志 log.warn(\"warn..., p1:{}\", 4); // 错误日志 log.error(\"error..., p1:{}\", 5); } } "},"src/guide/cache.html":{"url":"src/guide/cache.html","title":"缓存","keywords":"","body":"缓存 缓存组件包：com.wee0.box.cache 当前版本默认使用基于内存的缓存实现，如果需要切换到redis缓存，需要在框架配置文件box_config.properties中进行如下配置： # 基于内存的缓存实现，默认。 # com.wee0.box.cache.ICacheManager = com.wee0.box.cache.caffeine.CaffeineCacheManager # 基于redis的缓存实现。 com.wee0.box.cache.ICacheManager = com.wee0.box.cache.redis.RedisCacheManager 依赖配置： com.github.ben-manes.caffeine caffeine redis.clients jedis 代码中使用方式如下： import com.wee0.box.cache.CacheManager; import com.wee0.box.cache.ICache; import org.junit.*; public class CacheTest{ @Test public void test(){ // 获取test命名空间缓存对象 ICache _cache = CacheManager.impl().getCache(\"test\"); // 设置缓存，最大生命周期 _cache.put(\"string1\", \"string1.v\"); // 设置缓存，60秒后过期。 _cache.put(\"string2\", \"string2.v\", 60); Assert.assertEquals(\"string1.v\", cache.get(\"string1\")); Assert.assertEquals(\"string2.v\", cache.get(\"string2\")); // 读取缓存，重设60秒过期时间 cache.get(\"string2\", 60) // 清除缓存 _cache.clear(); } } "},"src/utils/utils.html":{"url":"src/utils/utils.html","title":"工具类","keywords":"","body":"工具类 com.wee0.box.util 包下，各种工具类的使用说明。 "},"src/utils/validateUtils.html":{"url":"src/utils/validateUtils.html","title":"校验工具","keywords":"","body":"校验工具类 根据业务规则验证传递的参数是否合法，各种详细校验方法请参考javadoc文档，这里重点讲一下模式校验。 示例代码： public boolean login(String loginId, String loginPwd) { if (!ValidateUtils.impl().validatePattern(loginId, \"S6-16\")) BizExceptionFactory.create(BizCodeDef.ValidateFailed, \"登陆标识不合法！\"); } 参考校验规则： *：检测是否有输入，可以输入任何字符，不留空即可通过验证。 *6-16：检测必须为6到16位长度的任意字符。 n：检测必须为数字类型。 n6-16：检测必须为6到16之间的数字。 s：字符串类型(支持中文、字母、数字、下划线), 不能有特殊字符。 s6-16：检测必须为字符串类型，且字符长度在6到16位之间。 S：非中文字符串类型(包含字母、数字、下划线), 不能有特殊字符。 S6-16：检测必须为非中文字符串类型，且字符长度在6到16位之间。 p：检测必须为邮政编码格式。 m：检测必须为手机号码格式。 e：检测必须为邮箱地址格式。 url：检测必须为网络地址格式。 reg：验证是否符合指定的正则表达式,忽略大小写,正则格式参照java代码Pattern.compile()参数要求。 "},"src/plugins/plugins.html":{"url":"src/plugins/plugins.html","title":"插件","keywords":"","body":"插件说明 通过插件可以在依赖一些第三方组件时，避免过多的jar包引入项目中带来的jar包冲突问题。 "},"src/plugins/plugins_dev.html":{"url":"src/plugins/plugins_dev.html","title":"插件开发","keywords":"","body":"插件开发 工程划分 插件分为两个工程：暴露给使用者可见的规范接口工程与使用者不可直接使用的接口实现工程。通常我们命名为“pluginName-api”与“pluginName-impl”。 接口工程可以在开发过程中加入到项目的依赖中直接引用，实现工程的相关产出与依赖物件放置在项目根目录下的plugins目录下的插件标识名称目录下，不可在开发过程中使用。 插件接口工程开发 创建一个普通的打包类型为“jar”的项目，如下： 4.0.0 com.wee0.box.plugins hello-api 0.1.0 ${project.artifactId} jar com.wee0.box box-api ${box.version} provided 编写插件操作主接口，插件可以定义多个暴露的接口，但是只能有一个主接口，作为统一的入口。package com.wee0.box.plugins.hello; import com.wee0.box.plugin.IPlugin; public interface IHelloPlugin extends IPlugin { String hello(String name); } 打包发布后就可以给项目开发人员引入项目中进行开发使用了。 插件实现工程开发 创建一个普通的打包类型为“jar”的项目，如下： 4.0.0 com.wee0.box.plugins hello-impl 0.1.0 ${project.artifactId} jar com.wee0.box.plugins hello-api 0.1.0 provided 编写插件规范接口实现逻辑。 package com.wee0.box.plugins.hello.impl; import com.wee0.box.plugins.hello.IHelloPlugin; public class HelloImpl implements IHelloPlugin { private static ILogger log = LoggerFactory.getLogger(HelloImpl.class); @Override public String hello(String name){ return \"hello\" + name; } @Override public void init(Map params) { log.debug(\"init... params: {}\", params); } @Override public void destroy() { log.debug(\"destroy...\"); } } 打包项目：mvn clean package。 导出项目依赖的所有第三方jar包：mvn dependency:copy-dependencies -DincludeScope=compile。 在项目中使用上边的插件实现 检查项目根目录下是否存在 “plugins” 目录，如果没有就新建一个。 在 “plugins” 目录下创建插件标识目录，当前版本无强制检查，可根据自己喜好建立，如：\"hello\"。 将插件实现工程的产出jar与 target/dependency 目录下导出的所有第三方依赖jar包，拷贝至 “plugins/hello” 目录中。 修改 config/box_config.properties 配置，启用插件。# 插件部分 # 使用的插件标识集合，多个之间用逗号隔开 plugin.ids=hello # 继承自IPlugin接口的插件主接口完全限定名称 plugin.hello.interface=com.wee0.box.plugins.hello.IHelloPlugin # 插件主接口实现类完全限定名称 plugin.hello.impl=com.wee0.box.plugins.hello.impl.HelloImpl # 插件自定义参数 plugin.hello.param1=test1 plugin.hello.param2=test2 搞定。 "},"src/faq/faq.html":{"url":"src/faq/faq.html","title":"FAQ","keywords":"","body":"常见问题 一些常见的问题及解决方法记录在此处 "}}